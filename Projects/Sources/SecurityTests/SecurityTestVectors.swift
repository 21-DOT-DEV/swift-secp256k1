//
//  SecurityTestVectors.swift
//  21-DOT-DEV/swift-secp256k1
//
//  Copyright (c) 2025 21-DOT-DEV
//  Distributed under the MIT software license
//
//  See the accompanying file LICENSE for information
//

import Foundation

/// Security test vectors organized by vulnerability class.
///
/// These vectors are used to validate that the library correctly rejects
/// known cryptographic attack patterns across ECDSA, ECDH, and Schnorr operations.
enum SecurityTestVectors {
    // MARK: - secp256k1 Curve Constants

    /// The secp256k1 curve order n
    /// n = FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141
    static let curveOrder: [UInt8] = [
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE,
        0xBA, 0xAE, 0xDC, 0xE6, 0xAF, 0x48, 0xA0, 0x3B,
        0xBF, 0xD2, 0x5E, 0x8C, 0xD0, 0x36, 0x41, 0x41
    ]

    /// The secp256k1 field prime p
    /// p = FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F
    static let fieldPrime: [UInt8] = [
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFC, 0x2F
    ]

    // MARK: - Point Validation Vectors (PV-001 through PV-004)

    enum PointValidation {
        /// PV-001: Point at infinity (compressed format with all zeros)
        /// The point at infinity has no valid encoding in compressed/uncompressed format
        static let infinityCompressed: [UInt8] = [0x02] + Array(repeating: 0x00, count: 32)

        /// PV-001: Point at infinity (uncompressed format)
        static let infinityUncompressed: [UInt8] = [0x04] + Array(repeating: 0x00, count: 64)

        /// PV-002: Point not on curve (twist point)
        /// A point with valid x but y that doesn't satisfy y² = x³ + 7
        /// x = 5 gives y² = 132, which has no square root in the field for either parity
        static let twistPoint: [UInt8] = {
            var point: [UInt8] = [0x02]
            point.append(contentsOf: Array(repeating: 0x00, count: 31))
            point.append(0x05)
            return point
        }()

        /// PV-003: Invalid x-coordinate (x > field prime p)
        /// x = p + 1 = FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC30
        static let invalidXCoordinate: [UInt8] = {
            var point: [UInt8] = [0x02]
            point.append(contentsOf: [
                0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFC, 0x30
            ])
            return point
        }()

        /// PV-004: Invalid y-coordinate in uncompressed point
        /// Valid x (generator point x) but wrong y that doesn't satisfy curve equation
        static let invalidYCoordinate: [UInt8] = {
            // Generator point x-coordinate
            let gx: [UInt8] = [
                0x79, 0xBE, 0x66, 0x7E, 0xF9, 0xDC, 0xBB, 0xAC,
                0x55, 0xA0, 0x62, 0x95, 0xCE, 0x87, 0x0B, 0x07,
                0x02, 0x9B, 0xFC, 0xDB, 0x2D, 0xCE, 0x28, 0xD9,
                0x59, 0xF2, 0x81, 0x5B, 0x16, 0xF8, 0x17, 0x98
            ]
            // Wrong y (just zeros - definitely not on curve)
            let wrongY: [UInt8] = Array(repeating: 0x00, count: 32)
            return [0x04] + gx + wrongY
        }()

        /// Valid compressed public key for comparison (generator point G)
        static let validCompressedKey: [UInt8] = [
            0x02,
            0x79, 0xBE, 0x66, 0x7E, 0xF9, 0xDC, 0xBB, 0xAC,
            0x55, 0xA0, 0x62, 0x95, 0xCE, 0x87, 0x0B, 0x07,
            0x02, 0x9B, 0xFC, 0xDB, 0x2D, 0xCE, 0x28, 0xD9,
            0x59, 0xF2, 0x81, 0x5B, 0x16, 0xF8, 0x17, 0x98
        ]
    }

    // MARK: - Scalar Validation Vectors (SV-001 through SV-003)

    enum ScalarValidation {
        /// SV-001: Zero private key
        static let zeroKey: [UInt8] = Array(repeating: 0x00, count: 32)

        /// SV-002: Scalar equal to curve order n (invalid, must be < n)
        static let scalarEqualToOrder: [UInt8] = SecurityTestVectors.curveOrder

        /// SV-002: Scalar greater than curve order (n + 1)
        static let scalarGreaterThanOrder: [UInt8] = [
            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE,
            0xBA, 0xAE, 0xDC, 0xE6, 0xAF, 0x48, 0xA0, 0x3B,
            0xBF, 0xD2, 0x5E, 0x8C, 0xD0, 0x36, 0x41, 0x42
        ]

        /// SV-003: Maximum valid scalar (n - 1)
        static let maxValidScalar: [UInt8] = [
            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE,
            0xBA, 0xAE, 0xDC, 0xE6, 0xAF, 0x48, 0xA0, 0x3B,
            0xBF, 0xD2, 0x5E, 0x8C, 0xD0, 0x36, 0x41, 0x40
        ]

        /// Valid private key for comparison
        static let validPrivateKey: [UInt8] = [
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01
        ]
    }

    // MARK: - Signature Malleability Vectors (SM-001 through SM-002)

    enum SignatureMalleability {
        /// Half of curve order (n/2) for low-s check
        /// n/2 = 7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0
        static let halfOrder: [UInt8] = [
            0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
            0x5D, 0x57, 0x6E, 0x73, 0x57, 0xA4, 0x50, 0x1D,
            0xDF, 0xE9, 0x2F, 0x46, 0x68, 0x1B, 0x20, 0xA0
        ]

        /// SM-001: High-s signature (s > n/2)
        /// This is a crafted signature with s = n/2 + 1
        static let highSSignature: [UInt8] = {
            // Valid r value (32 bytes)
            let r: [UInt8] = [
                0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                0x5D, 0x57, 0x6E, 0x73, 0x57, 0xA4, 0x50, 0x1D,
                0xDF, 0xE9, 0x2F, 0x46, 0x68, 0x1B, 0x20, 0xA0
            ]
            // High s value (s = n/2 + 1)
            let s: [UInt8] = [
                0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                0x5D, 0x57, 0x6E, 0x73, 0x57, 0xA4, 0x50, 0x1D,
                0xDF, 0xE9, 0x2F, 0x46, 0x68, 0x1B, 0x20, 0xA1
            ]
            return r + s
        }()
    }

    // MARK: - Zero/Invalid Signature Vectors (ZS-001 through ZS-004)

    enum ZeroSignature {
        /// ZS-001: Signature with r = 0
        static let zeroR: [UInt8] = {
            let r = Array(repeating: UInt8(0x00), count: 32)
            let s: [UInt8] = [
                0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                0x5D, 0x57, 0x6E, 0x73, 0x57, 0xA4, 0x50, 0x1D,
                0xDF, 0xE9, 0x2F, 0x46, 0x68, 0x1B, 0x20, 0x00
            ]
            return r + s
        }()

        /// ZS-002: Signature with s = 0
        static let zeroS: [UInt8] = {
            let r: [UInt8] = [
                0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                0x5D, 0x57, 0x6E, 0x73, 0x57, 0xA4, 0x50, 0x1D,
                0xDF, 0xE9, 0x2F, 0x46, 0x68, 0x1B, 0x20, 0x00
            ]
            let s = Array(repeating: UInt8(0x00), count: 32)
            return r + s
        }()

        /// ZS-003: "Psychic signature" - both r = 0 and s = 0 (CVE-2022-21449)
        static let psychicSignature: [UInt8] = Array(repeating: 0x00, count: 64)

        /// ZS-004: Schnorr signature with zero R point
        /// 64-byte Schnorr signature: first 32 bytes are R x-coordinate, last 32 are s
        static let schnorrZeroR: [UInt8] = {
            let r = Array(repeating: UInt8(0x00), count: 32)
            let s: [UInt8] = [
                0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                0x5D, 0x57, 0x6E, 0x73, 0x57, 0xA4, 0x50, 0x1D,
                0xDF, 0xE9, 0x2F, 0x46, 0x68, 0x1B, 0x20, 0x00
            ]
            return r + s
        }()
    }

    // MARK: - DER Encoding Vectors (DE-001 through DE-004)

    enum DEREncoding {
        /// DE-001: BER padding (extra leading zeros in length)
        /// Valid DER would use 0x30 0x44, but BER allows 0x30 0x81 0x44
        static let berPadding: [UInt8] = [
            0x30, 0x81, 0x44, // BER-style length encoding (should be just 0x30, 0x44)
            0x02, 0x20, // r INTEGER, 32 bytes
            0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
            0x5D, 0x57, 0x6E, 0x73, 0x57, 0xA4, 0x50, 0x1D,
            0xDF, 0xE9, 0x2F, 0x46, 0x68, 0x1B, 0x20, 0x00,
            0x02, 0x20, // s INTEGER, 32 bytes
            0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
            0x5D, 0x57, 0x6E, 0x73, 0x57, 0xA4, 0x50, 0x1D,
            0xDF, 0xE9, 0x2F, 0x46, 0x68, 0x1B, 0x20, 0x00
        ]

        /// DE-002: Unnecessary leading 0x00 prefix (negative encoding protection when not needed)
        /// r value has 0x00 prefix but high bit is not set
        static let unnecessaryPadding: [UInt8] = [
            0x30, 0x46, // SEQUENCE, 70 bytes
            0x02, 0x21, // r INTEGER, 33 bytes (one extra)
            0x00, // Unnecessary padding
            0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
            0x5D, 0x57, 0x6E, 0x73, 0x57, 0xA4, 0x50, 0x1D,
            0xDF, 0xE9, 0x2F, 0x46, 0x68, 0x1B, 0x20, 0x00,
            0x02, 0x20, // s INTEGER, 32 bytes
            0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
            0x5D, 0x57, 0x6E, 0x73, 0x57, 0xA4, 0x50, 0x1D,
            0xDF, 0xE9, 0x2F, 0x46, 0x68, 0x1B, 0x20, 0x00
        ]

        /// DE-003: Non-minimal length encoding
        /// Uses two-byte length form when one byte would suffice
        static let nonMinimalLength: [UInt8] = [
            0x30, 0x82, 0x00, 0x44, // Length encoded as 0x82 0x00 0x44 instead of just 0x44
            0x02, 0x20,
            0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
            0x5D, 0x57, 0x6E, 0x73, 0x57, 0xA4, 0x50, 0x1D,
            0xDF, 0xE9, 0x2F, 0x46, 0x68, 0x1B, 0x20, 0x00,
            0x02, 0x20,
            0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
            0x5D, 0x57, 0x6E, 0x73, 0x57, 0xA4, 0x50, 0x1D,
            0xDF, 0xE9, 0x2F, 0x46, 0x68, 0x1B, 0x20, 0x00
        ]

        /// DE-004: Valid strict DER encoding
        static let validStrictDER: [UInt8] = [
            0x30, 0x44, // SEQUENCE, 68 bytes
            0x02, 0x20, // r INTEGER, 32 bytes
            0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
            0x5D, 0x57, 0x6E, 0x73, 0x57, 0xA4, 0x50, 0x1D,
            0xDF, 0xE9, 0x2F, 0x46, 0x68, 0x1B, 0x20, 0x00,
            0x02, 0x20, // s INTEGER, 32 bytes
            0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
            0x5D, 0x57, 0x6E, 0x73, 0x57, 0xA4, 0x50, 0x1D,
            0xDF, 0xE9, 0x2F, 0x46, 0x68, 0x1B, 0x20, 0x00
        ]
    }

    // MARK: - Invalid Curve Attack Vectors (IC-001 through IC-002)

    // These vectors are derived from libsecp256k1/src/tests.c invalid point test cases

    enum InvalidCurve {
        /// IC-001: Truncated public key (not enough bytes)
        /// A malformed key that's too short to be valid
        static let truncatedKey: [UInt8] = [0x02, 0x79, 0xBE, 0x66] // Only 4 bytes after header

        /// IC-002: Invalid header byte
        /// A key with an invalid format prefix (0x05 is not valid)
        static let invalidHeaderKey: [UInt8] = {
            var point: [UInt8] = [0x05] // Invalid header (not 0x02, 0x03, or 0x04)
            point.append(contentsOf: [
                0x79, 0xBE, 0x66, 0x7E, 0xF9, 0xDC, 0xBB, 0xAC,
                0x55, 0xA0, 0x62, 0x95, 0xCE, 0x87, 0x0B, 0x07,
                0x02, 0x9B, 0xFC, 0xDB, 0x2D, 0xCE, 0x28, 0xD9,
                0x59, 0xF2, 0x81, 0x5B, 0x16, 0xF8, 0x17, 0x98
            ])
            return point
        }()

        // MARK: - libsecp256k1 Invalid Point Test Vectors

        // From Vendor/secp256k1/src/tests.c - these are real cryptographic edge cases

        /// Point on twist curve y² = x³ + 9 (not secp256k1's y² = x³ + 7)
        /// x is third root of -8, y is -1 * (x³+7)
        static let twistCurvePoint: [UInt8] = [
            0x04, // Uncompressed
            0x0A, 0x2D, 0x2B, 0xA9, 0x35, 0x07, 0xF1, 0xDF, 0x23, 0x37, 0x70, 0xC2, 0xA7, 0x97, 0x96, 0x2C,
            0xC6, 0x1F, 0x6D, 0x15, 0xDA, 0x14, 0xEC, 0xD4, 0x7D, 0x8D, 0x27, 0xAE, 0x1C, 0xD5, 0xF8, 0x53,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01
        ]

        /// x overflow attack: x = p + 1 (would be valid if overflow to x=1 ignored)
        /// From libsecp256k1 tests.c
        static let xOverflowPoint: [UInt8] = [
            0x04, // Uncompressed
            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFC, 0x30,
            0x42, 0x18, 0xF2, 0x0A, 0xE6, 0xC6, 0x46, 0xB3, 0x63, 0xDB, 0x68, 0x60, 0x58, 0x22, 0xFB, 0x14,
            0x26, 0x4C, 0xA8, 0xD2, 0x58, 0x7F, 0xDD, 0x6F, 0xBC, 0x75, 0x0D, 0x58, 0x7E, 0x76, 0xA7, 0xEE
        ]

        /// x = p - 1 (i.e., -1 mod p), on curve y² = x³ - 5 (not secp256k1)
        /// From libsecp256k1 tests.c
        static let xNegativeOnePoint: [UInt8] = [
            0x04, // Uncompressed
            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFF, 0xFC, 0x2E,
            0xF4, 0x84, 0x14, 0x5C, 0xB0, 0x14, 0x9B, 0x82, 0x5D, 0xFF, 0x41, 0x2F, 0xA0, 0x52, 0xA8, 0x3F,
            0xCB, 0x72, 0xDB, 0x61, 0xD5, 0x6F, 0x37, 0x70, 0xCE, 0x06, 0x6B, 0x73, 0x49, 0xA2, 0xAA, 0x28
        ]

        /// x = 0, y on curve y² = x³ - 7 (not secp256k1)
        /// From libsecp256k1 tests.c
        static let xZeroInvalidY: [UInt8] = [
            0x04, // Uncompressed
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x8F, 0x53, 0x7E, 0xEF, 0xDF, 0xC1, 0x60, 0x6A, 0x07, 0x27, 0xCD, 0x69, 0xB4, 0xA7, 0x33, 0x3D,
            0x38, 0xED, 0x44, 0xE3, 0x93, 0x2A, 0x71, 0x79, 0xEE, 0xCB, 0x4B, 0x6F, 0xBA, 0x93, 0x60, 0xDC
        ]
    }

    // MARK: - Nonce Security Vectors (NS-001 through NS-003)

    enum NonceSecurity {
        /// NS-001: Test message for deterministic nonce verification
        static let testMessage: [UInt8] = Array("test message for deterministic nonce".utf8)

        /// NS-003: Constant session ID (should produce same nonce with same inputs)
        static let constantSessionID: [UInt8] = Array(repeating: 0x42, count: 32)

        /// Valid 32-byte message hash for MuSig2 operations
        static let testMessageHash: [UInt8] = [
            0xE3, 0xB0, 0xC4, 0x42, 0x98, 0xFC, 0x1C, 0x14,
            0x9A, 0xFB, 0xF4, 0xC8, 0x99, 0x6F, 0xB9, 0x24,
            0x27, 0xAE, 0x41, 0xE4, 0x64, 0x9B, 0x93, 0x4C,
            0xA4, 0x95, 0x99, 0x1B, 0x78, 0x52, 0xB8, 0x55
        ]
    }
}
